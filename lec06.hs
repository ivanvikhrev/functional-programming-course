import Prelude hiding (scanl, scanr, map, elem, filter, reverse)

-------------------------------------------------
-- Домашнее задание 6
-------------------------------------------------

-- 1. Для каждого из следующих типов напишите какой-нибудь терм, имеющий этот тип.

-- (a -> a) -> a -> a
-- (a -> b) -> a -> b
-- ((a -> b) -> a) -> (a -> b) -> b
-- ((a -> b) -> (b -> c)) -> (a -> b) -> a -> c

-- 2. Не используя явно рекурсию, напишите функцию findIndices :: (a ->
-- Bool) -> [a] -> [Int], находящую индексы тех элементов в списке, на
-- которых условие возвращает True. Можно использовать библиотечные
-- функции.

-- 3. Используя foldr и не используя явно рекурсию, напишите функцию
-- composeAll :: [a -> a] -> (a -> a), берущую список функций и
-- возвращающая их последовательную композицию (функция, являющаяся
-- головой списка, применяется последней). Например, composeAll [(^2),
-- (*2), (+3)] 0 = 36.

-- 4. Функция shows имеет тип a -> String -> String, если a — тип печатаемых
-- значений. shows x s возвращает строку, являющуюся конкатенацией
-- текстового представления x и s.

-- Следующая функция должна возвращать строку, являющуюся
-- конкатенацией текстовых представлений всех элементов
-- списка-аргумента.

g :: Show a => [a] -> String
g = (foldr ((.) . shows) id) ""

-- В этом определении есть ошибка типов. Исправьте ее, внеся минимальные
-- изменения, и напишите тип каждого подвыражения исправленной правой
-- части. Эти типы должны соответствовать типу всего выражения.
-- Например, если в данной функции id требует тип String -> String, то
-- нужно писать именно так, несмотря на то, что в документации id
-- имеет тип a -> a.

-- 5. Подставьте определение (.) в терм (.) . shows и найдите нормальную
-- форму полученного терма.

-------------------------------------------------
-- Конспект лекции 6 от 22.03.2021
-------------------------------------------------

-- Решение домашнего задания 5 см. в конце файла

-- См. также "Лекции по функциональному программированию" на source.unn.ru.

-- Содержание

-- 1. Лямбда-исчисление с простыми типами.
-- 2. Параметрический полиморфизм.
-- 3. Определение типов подвыражений и нахождение типовых ошибок.
-- 4. Редукции и конверсии в лямбда-исчислении.

-------------------------------------------------
-- 1. λ-исчисление с простыми типами
-------------------------------------------------

-- Термы определяются грамматикой m ::= x | m m | λx. m.

-- Термы вида m n называются аппликацией, а λx. m —
-- (λ-)абстракцией. Терм λx. m определяет анонимную
-- функцию с формальным параметром (аргументом) x и телом m.

-- Аппликации группируется налево: m n k есть (m n) k.
-- λx y. m есть сокращение для λx. λy. m.

-- Переменная x считается связанной в терме λx. m. Переменные, у
-- которых есть хотя бы одно несвязанное вхождение в терме, называются
-- свободными. Связанные переменные можно свободно переименовывать.
-- Это называется α-конверсией. В этом смысле выражение λx. m
-- ведет себя во многом также, как ∀x. m или ∃x. m.

-- В Haskell вместо λx y z. m пишется \x y z -> m.

-- m[n/x] обозначает подстановку терма n в терм m вместо свободных
-- вхождений переменной x.

-- Типы определяются грамматикой a ::= b | a -> a. Здесь b пробегает
-- по множество базовых типов, например, Bool, Int, String.
-- Пример типа: (Int -> Bool) -> String.

-- Не все термы бестипового исчисления имеют смысл с точки зрения типов.
-- Например, x x есть терм, но если x представляет функцию из a в
-- b, то аргумент x должен иметь тип a, что приводит к уравнению на
-- типы a -> b = a. У этого уравнения нет конечных решений.

-- Правила типизации

-- Контекст Γ есть последовательность x1 : a1, x2 : a2, ..., xn : an,
-- где xi — переменные, ai — типы. Для исчисления с простыми типами
-- контекст можно также рассматривать как множество, на для более
-- выразительных типов порядок переменных важен.

-- Выводимые суждения имеют вид Γ |- M : a, где M — терм, a — тип. Для
-- правил ниже выполняется утверждение: если Γ |- M : a выводится, то
-- все свободные переменные терма M встречаются в Γ. Смысл: если
-- свободные переменные в M имеют типы, как указано в Γ, то терм M
-- имеет тип a.

-- Аксиома

-- Γ, x : a |- x : a (Var)

-- Правила вывода

--    Γ, x : a |- M : b
-- -------------------------------- (Abs)
-- Γ |- (λx. M) : a -> b

-- Γ |- M : a -> b    Γ |- N : a
-- ------------------------------ (App)
--          Γ |- M N : b

-- Пример 1

--   --------------- (Var)
--    x : a |- x : a
-- ----------------------- (Abs)
-- |- (λx. x) : a -> a

-- Проверка: наберите :t \x -> x в интерпретаторе

-- Пример 2

--    --------------------- (Var)
--    x : a, y : b |- x : a
--   ---------------------------- (Abs)
--    x : a |- (λy : b. x) : b -> a
-- ------------------------------------ (Abs)
-- |- (λx. λy. x) : a -> b -> a

-- Проверка: наберите :t \x -> \y -> x

-- Пример 3

-- В этом выводе Γ обозначает контекст f : b -> c, g : a -> b, x : a.

--                             --------------- (Var)  ---------- (Var)
--                             Γ |- g : a -> b       Γ |- x : a
--     --------------- (Var)   --------------------------------
--      Γ |- f : b -> c              Γ |- g x : b
--     -------------------------------------------- (App)
--     f : b -> c, g : a -> b, x : a |- f (g x) : c
--   ---------------------------------------------------- (Abs)
--     f : b -> c, g : a -> b |- λx. f (g x) : a -> c
-- --------------------------------------------------------------- (Abs)
-- f : b -> c |- λg. λx. f (g x) : (a -> b) -> a -> c
-- --------------------------------------------------------------- (Abs)
-- |- λf. λg. λx. f (g x) : (b -> c) -> (a -> b) -> a -> c

-- Проверка: наберите :t \f g x -> f (g x)

-------------------------------------------------
-- 2. Параметрический полиморфизм
-------------------------------------------------

-- Нaskell использует обобщение простых типов. Так, в Haskell есть
-- параметрический полиморфизм. Типы могут содержать переменные, и в
-- начале типа должны стоять неявные кванторы всеобщности по этим
-- переменным. Например,

-- length :: [a] -> Int

-- означает на самом деле ∀ a. [a] -> Int, то есть вместо a может быть
-- подставлен любой тип. Любая такая подстановка дает правильный тип
-- функции length. Так, [Int] -> Int, [Bool] -> Int, [String -> Float] -> Int
-- все являются типами length. В этом можно убедиться в командной строке.

-- > :t length :: [Bool] -> Int
-- length :: [Bool] -> Int :: [Bool] -> Int

-- Здесь length :: [Bool] -> Int -- выражение, а не объявление
-- функции. Такое приведение типа может использоваться в разных
-- контекстах.

-------------------------------------------------
-- 3. Определение типов подвыражений и нахождение типовых ошибок
-------------------------------------------------

-- В Prelude есть функция (бесточечная запись)

-- concatMap :: (a -> [b]) -> [a] -> [b]
-- concatMap f = concat . map f

-- Например, concatMap (replicate 3) "abc" = "aaabbbccc".

-- Следующая функция должна делать то же самое, но проходить
-- исходный список в обратном порядке. То есть
-- reverseConcatMap (replicate 3) "abc" = "cccbbbaaa".

-- Рассмотрим следующее ошибочное определение.

-- reverseConcatMap :: (a -> [b]) -> [a] -> [b]
-- reverseConcatMap f = foldl (flip . (++) . f) []

-- С учетом типа функции выпишем типы всех подвыражений правой
-- части определения.

-- Как было сказано выше, переменные a и b в типе reverseConcatMap
-- пробегают по произвольным типам. Фиксируем a и b, и типы остальных
-- подвыражений напишем через них. Важно: тип каждого подвыражения не
-- обязательно являются наиболее общим. Он такой, какой требуется для
-- типизации всего выражения.

-- Из типа функции видно, что

-- f :: a -> [b]

-- Для того, чтобы (++) . f имело смысл, область значений f должна
-- совпадать с областью определния (++). Поэтому в данной задаче
-- неправильно написать (++) :: [a] -> [a] -> [a]. Это верно в том
-- смысле, что (++) :: ∀ a. [a] -> [a] -> [a]. Однако при
-- фиксированных a и b из типа reverseConcatMap вхождение функции (++)
-- уже не может иметь тип [a] -> [a] -> [a].

-- (++) :: [b] -> [b] -> [b]
-- (++) . f :: a -> [b] -> [b]

-- Теперь становится видно, что с учетом типа flip:

-- flip :: ∀ a b c. (a -> b -> c) -> b -> a -> c

-- выражение flip . (++) . f не типизируемо. Действительно, (++) . f
-- возвращает значения типа [b] -> [b], то есть функции одного
-- аргумента, а flip ожидает функцию двух аргументов.

-- Скорее всего, вместо flip . (++) . f имелось в виду
-- flip $ (++) . f. Тогда имеем:

-- flip $ (++) . f :: [b] -> a -> [b]
-- foldl :: ([b] -> a -> [b]) -> [b] -> [a] -> [b]

-- Здесь снова нельзя написать тип foldl, который печатает Haskell:

-- foldl :: (b -> a -> b) -> b -> [a] -> b

-- потому что это наиболее общий тип. В данном определении
-- тип foldl есть некоторый частный случай этого общего типа.

-- foldl (flip $ (++) . f) :: [b] -> [a] -> [b]
-- foldl (flip $ (++) . f) [] :: [a] -> [b]

-- Итак, правильное определение имеет вид

reverseConcatMap :: (a -> [b]) -> [a] -> [b]
reverseConcatMap f = foldl (flip $ (++) . f) []

-------------------------------------------------
-- 4. Редукции и конверсии в λ-исчислении
-------------------------------------------------

-- В λ-исчислении есть две основных редукции.

-- β-редукция: терм (\x -> m) n редуцируется (переписывается) к
-- результату подстановки n вместо x в m. Это подстановка фактического
-- параметра вместо формального в тело функции при ее вызове.

-- η-редукция: \x -> m x редуцируется к m, если x не входит свободно в m.
-- Действительно, эти два терма ведут себя одинаково, когда
-- выступают в роли функции: ((\x -> m x) n) β-редуцируется к
-- результату подстановки n вместо x в m x, то есть в m n
-- (здесь используется то, что x не входит свободно в m).

-- Обе эти редукции можно совершать не только на верхнем уровне,
-- но и в глубине терма.

-- Выражение вида (\x -> m) n называется β-редексом (от reducible
-- expression). Аналогично выражение вида \x -> m x, где x не входит
-- свободно в m, называется η-редексом. Про терм, который не содержит
-- редексов, говорят, что он находится в нормальной форме. Если
-- m =βη n и n находится в нормальной форме, то n называется нормальной
-- формой терма m.

-- Таким образом, редукции являются бинарными отношениями на множестве
-- термов. Назовем β- и η-конверсиями, или β- и η-равнствами,
-- рефлексивные, симметричные и транзитивные замыкания соответствующих
-- редукций. (Эта терминология нексолько отличается в разных
-- учебниках.) Таким образом, два терма называются β-равными, если один
-- получается из другого с помощью конечной цепочки β-редукций в ту
-- или другую сторону. β- и η-равенства обозачаются =β и =η,
-- соответственно. Их объединение обозначается =βη. Однако часто будет
-- записываться просто =.

-- Кроме того, как было сказан выше, α-конверсия позволяет
-- переимновывать связанные переменные. Обычно α-равные термы
-- считаются одним и тем же термом.

-- η-равенство ответствено за бесточечную запись. Например, (++) можно
-- определить следующим образом.

append l1 l2 = foldr (\h p -> h : p) l2 l1

-- Однако \p -> h : p = \p -> ((:) h) p =η (:) h. Далее,
-- \h -> \p -> h : p =η \h -> (:) h =η (:). Поэтому append можно
-- переписать следующим образом.

-- append l1 l2 = foldr (:) l2 l1

-- то есть

-- append = \l1 l2 -> foldr (:) l2 l1

-- К этому терму η-редукцию неприменима. Однако если переставить
-- аргументы, то полученный терм можно сократить.

-- \l2 l1 -> foldr (:) l2 l1 =η foldr (:),

-- поэтому можно написать append = flip $ foldr (:).

-- Докажем некоторые равенства с помощью конверсий.

-- Домашнее задание 4, задача 1(1)

-- \x y -> x+1  =  const . (+1)

-- const . (+1) = (.) const (+1)
-- =  (\f g x -> f (g x)) const (+1) по определению (.)
-- =β \x -> const ((+1) x)
-- =  \x -> (\x y -> x) ((+1) x)     по определению const
-- =β \x y -> ((+1) x)
-- =  \x y -> ((\x -> x+1) x)        по определению (+1)
-- =β \x y -> x+1.

-- Лекция 5

-- (\x y -> y+1) = const (+1)

-- const (+1) = (\x y -> x) (+1)    по определению const
-- =β \y -> (+1)
-- =  \y -> \x -> x+1               по определению (+1)
-- =α \x y -> y+1

-- Домашнее задание 4, задача 1(2)

-- \x y = y x  и  flip id

-- flip id = (\f x y -> f y x) (\x -> x) по определению flip и id
-- =β \x y -> (\x -> x) y x
-- =β \x y -> y x

-------------------------------------------------
-- Решение домашнего задания 5
-------------------------------------------------

-- 1. Выразите функции elem и filter через foldr.

-- Бесточечная запись

elem :: Eq a => a -> [a] -> Bool
elem x = foldr (\y z -> x == y || z) False

filter :: (a -> Bool) -> [a] -> [a]
filter p = foldr (\x y -> if p x then x : y else y) []

-- 2. Выразите reverse через (:) и foldl.

reverse :: [a] -> [a]
reverse = foldl (flip (:)) []

-- 3. Объясните следующую реализацию map.

map f = foldr ((:) . f) []

-- Объяснение с использованием β- и η-конверсий.

-- (:) . f = (.) (:) f
-- =  (\f g x -> f (g x)) (:) f   по определению (.)
-- =β \x -> (:) (f x)
-- =η \x y -> (:) (f x) y

-- Значит, foldr ((:) . f) [] =βη \xs -> foldr (\x y -> f x : y) [] xs

-- Таким образом, эта функция применяет f к голове xs и присоединяет
-- возвращаемое значение к результату рекурсивного вызова на хвосте xs.

-- Напишите тип каждого подвыражения.

-- map :: (a -> b) -> [a] -> [b]

-- f :: a -> b
-- foldr :: (a -> [b] -> [b]) -> [b] -> [a] -> [b]
-- (:) :: b -> [b] -> [b]
-- (.) :: (b -> [b] -> [b]) -> (a -> b) -> a -> [b] -> [b]
-- (.) (:) :: (a -> b) -> a -> [b] -> [b]
-- (.) (:) f = (:) . f :: a -> [b] -> [b]
-- foldr ((:) . f) :: [b] -> [a] -> [b]
-- foldr ((:) . f) [] :: [a] -> [b]

-- Таким образом, map f :: [a] -> [b].

-- 4. С помощью foldl или foldr напишите функцию horner :: [Double] ->
-- Double -> Double, которая с помощью метода Горнера (см. Википедия)
-- вычисляет значение полинома, заданного списком своих коэффициентов,
-- на втором аргументе.

-- Пусть старший коэффициент находится в начале списка, а младший — в конце.

horner :: [Double] -> Double -> Double
horner poly x = foldl (\p a -> p * x + a) 0 poly

-- 5. В Prelude есть функции scanl и scanr, которые похожи на foldl
-- и foldr, но они возвращают не только свертку всего списка, но
-- список, состоящий из свертков всех префиксов (соответственно, суффиксов)
-- списка. То есть

-- scanl f z [x1, x2, ..., xn] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
-- scanr f z [x1, x2, ..., xn] == [..., x(n-1) `f` (xn `f` z), xn `f` z, z]

-- В некотором смысле scanl и scanr можно рассматривать как трассировку
-- foldl и foldr.

-- Напишите scanl с помощью хвостовой рекурсии и scanr с помощью
-- нехвостовой рекурсии.

scanl f z [] = [z]
scanl f z (x : xs) = z : scanl f (f z x) xs

scanr f z [] = [z]
scanr f z (x : xs) = let p = scanr f z xs in f x (head p) : p

-- В следующих заданиях не используйте явную рекурсию.
-- Можно использовать библиотечные функции.

-- 6. Как известно, гармонический ряд (сумма 1/k для k от 1 до
-- бесконечности) расходится. Более точно, сумма 1/k для k от 1 до n
-- при больших n ведет себя, как ln(n) + gamma, где gamma =
-- 0,5772156649... есть постоянная Эйлера. С помощью scanl, но не
-- используя явную рекурсию, напишите функцию harmonicSeriesExceeds ::
-- Double -> Int, такую что harmonicSeriesExceeds x возвращает
-- натуральное число n, при котором сумма 1/k для k от 1 до n в первый
-- раз превосходит x. Для конкретных x и соответствующих n проверьте,
-- что (sum (map (1/) [1..n-1])) <= x и (sum (map (1/) [1..n])) > x.

harmonicSeriesExceeds :: Double -> Int
harmonicSeriesExceeds s = 1 + (length $ takeWhile (<= s) $ scanl1 (+) (map (1 /) [1..]))

-- 7. См. задание в файле hw05.pdf.

-- pi = 4 * (1 - 1/3 + 1/5 - 1/7 + ...)

approxPi :: [Double]
approxPi = map (*4) (scanl1 (+) piSeq)
  where piSeq = zipWith (/) (iterate negate 1) [1,3..]

square :: Double -> Double
square x = x * x

eulerTransform :: [Double] -> [Double]
eulerTransform (x : y : z : rest) =
  z - square (z - y) / (x - 2 * y + z) : eulerTransform (y : z : rest)

fastApproxPi :: [Double]
fastApproxPi = map head (iterate eulerTransform approxPi)
