-- Домашнее задание находится в конце файла.

-------------------------------------------------
-- Конспект лекции 11 от 26.04.2021
-------------------------------------------------

import Control.Monad

-- Содержание

-- 1. Функция return.
-- 2. do-нотация.

-------------------------------------------------
-- 1. Функция return
-------------------------------------------------

-- В этой лекции идет речь о конструкторах типа, например, Maybe и [],
-- то есть о функциях, которые принимают и возвращают тип.  В таких
-- фразах, как "объявить конструктор типа монадой" или "конструктор
-- типа m", слова "конструктор типа" являются неделимой идиомой. Так,
-- вторая фраза означает, что m — это конструктор типа, а не то, что
-- конструктор имеет тип m.

-- Напоминание: монада — это конструктор типа m, для которого
-- определена функция (>>=) :: m a -> (a -> m b) -> m b, похожая на
-- применение функции к аргументу. Эта функция также называется then
-- или bind.

-- На прошлой лекции были рассмотрены три монады: Maybe, Either e
-- (здесь e — любой тип и Either ожидает еще один тип в качестве
-- аргумента) и [] (тип списков). Членство этих конструкторов в
-- классе Monad определено в Prelude.

-- В дополнение к (>>=) в монаде должна быть определена функция return
-- :: a -> m a, также называемая unit. Напомним, что в лекции 10
-- значения монадного типа m a назывались причудливыми ("fancy
-- values"). Причудливые значения — это обычные значения и/или
-- дополнительная информация (иногда говорят "значения в контексте"
-- или "значения в контейнере"), например: чистое значение или
-- Nothing, значение в списке и т.д. В дальнейшем мы будем называть их
-- монадными значениями. Функция return превращает обычное значение в
-- монадное, обычно каким-то наиболее простым способом.

-- Примеры return для монад из прошлой лекции

returnMaybe :: a -> Maybe a
returnMaybe v = Just v

returnEither :: a -> Either String a
returnEither v = Right v

returnList :: a -> [a]
returnList v = [v]

-- Нужно отметить, что return не имеет ничего общего с одноименным
-- оператором в императивных языках программирования. Там return
-- указывает значение, возвращаемое функцией, и заканчивает работу
-- функции. В Haskell return является такой же математической
-- функцией, как и все остальные.

-- Зачем нужен return? Обратите внимание, что второй аргумент функции
-- (>>=) :: m a -> (a -> m b) -> m b возвращает монадное значение.
-- Поэтому в выражении mv >>= (\v -> ...)  mv является монадным
-- значением, v является чистым значением, содержащимся в mv, а на
-- месте многоточия должно стоять еще одно монадное значение
-- (возможно, другого типа, чем mv). Часто оно конструируется из v, и
-- для этого используется return.

-- Например, пусть мы хотим написать функцию, которая переделывает
-- Just n в Just (n+1), а Nothing в Nothing.

incMaybe :: Maybe Int -> Maybe Int
incMaybe mv = mv >>= (\n -> Just (n+1))

-- Проверим типы

-- mv :: Maybe Int
-- Just (n+1) :: Maybe Int, если n :: Int
-- \n -> return (n+1) :: Int -> Maybe Int
-- mv >>= (\n -> Just (n+1)) :: Maybe Int

-- Если вместо Just написать return, то полученная функция будет иметь
-- более общий тип.

incM :: Monad m => m Int -> m Int
incM mv = mv >>= (\n -> return (n+1))

-- Функция incM работает на всех монадах.

-- incM (Just 5) = Just 6
-- incM (Right 5) = (Right 6)
-- incM [5] = [6]
-- incM [1, 2, 3] = [2, 3, 4]
-- incM Nothing = Nothing
-- incM [] = []

-------------------------------------------------
-- do-нотация
-------------------------------------------------

-- В Haskell есть гораздо более удобная запись для >>=. Например, вместо

-- threeSteps :: [(Int, Int)] -> Int -> [Int]
-- threeSteps graph v =
--   step v  >>= \v1 ->
--   step v1 >>= \v2 ->
--   step v2
--     where step u = lookupList u graph

-- из предыдущей лекции пишется

-- threeSteps graph v =
--   do v1 <- step v
--      v2 <- step v1
--      step v2
--    where step u = lookupList u graph

-- В общем случае

-- do p <- e
--    stmts

-- преобразуется в

-- e >>= (\p -> do stmts)
-- где do stmts рекурсивно преобразовывается по тому же правилу.

-- В do-выражении выше переменная p является связанной в stmts, как видно
-- из его эквивалента с >>=. На самом деле, p может быть произвольным
-- образцом, как в любом лямбда-выражении. Так, если p не используется
-- в stmts, можно написать 

-- do _ <- e
--    stmts

-- Для этого случая есть более компактная запись

-- do e
--    stmts

-- которая преобразуется в

-- e >> (do stmts)

-- где функция (>>) определена следующим образом.

-- (>>) :: Monad m => m a -> m b -> m b
-- mv >> mw = mv >>= (\_ -> mw)

-- Пример. Предположим, мы хотим проверить наличие элемента в
-- ассоциативном списке с помощью функции
-- lookup :: Eq a => a -> [(a, b)] -> Maybe b из Prelude,
-- но нас не интересует значение из соответствующей пары.

occurs :: Eq a => a -> [(a, b)] -> Maybe ()
occurs v dict =
  do lookup v dict
     return ()

-- или lookup v >>= \_ -> Just ()

-- lookup 1 [(1,2),(3,4)] = Just 2
-- occurs 1 [(1,2),(3,4)] = Just ()
-- occurs 2 [(1,2),(3,4)] = Nothing

-- Важно помнить, что в выражении, например,
-- do x1 <- e1
--    x2 <- e2
--    e3
--    x4 <- e4
--    e5
-- все выражения от e1 до e5 должны иметь монадный тип. Как было сказано,
-- в последнем выражении для этого часто используется return.

-- Do-запись можно чередовать с let и if. Например,

-- do x <- Just 3
--    let y = x*x
--    return (x + y)

-- Переменная y связана в выражениях, идущих после let. В отличие от
-- let-выражения, введенного в лекции 1, за let, являющимся частью
-- do-нотации, не следует in. Также важно, что правая часть в let
-- может быть произвольного (не обязательно монадного) типа. Как и в
-- случае с обычными let-выражениями, значению правой части просто
-- дается новое имя y.

-- Пример с if

-- do x <- Just 3
--    if even x then return x else return (x+1)

-- Здесь if-выражения должно иметь монадный тип, как любая часть do.

-- Для do-записи важен размер отступа. Колонка, в которой начинается
-- следующая после do лексема (она может быть на следующей строке),
-- запоминается, и если следующая строчка начинается с того же
-- отступа, то она считается новой частью do, если с большего отступа,
-- то продолжением предыдущей части, а если с меньшего отступа, то
-- следующим за do выражением. Эти правила также применяются к
-- ключевым словам where, let и of. См. §2.7 в Haskell 2010 Language
-- Report.

-- Более подробно про do-запись см. в Haskell 2010 Language Report, §3.14.

-------------------------------------------------
-- Домашнее задание
-------------------------------------------------

-- 1. Перепишите выражение
-- do x <- f a
--    y <- g x
--    h y
--    j x y
-- с помощью >>=.

-- 2. Перепишите функции nSteps из лекции 10 и goodString из домашнего
-- задания 10 с помощью do-нотации.

-- 3. Напишите функцию composeM :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c,
-- которая возвращает композицию двух монадных функций. В Control.Monad такая
-- функция называется (>=>).

-- 4. Напишите функцию maybeList :: [Maybe a] -> Maybe [a]. Если в
-- списке-аргументе содержится хотя бы одно значение Nothing, то
-- функция возвращает Nothing. В противном случае
-- maybeList [Just x1, ..., Just xn] возвращает Just [x1, ..., xn].
-- Напишите эту функцию с использованием do-записи, но без монадных
-- функций из стандартной библиотеки. На самом деле, кроме do и return
-- достаточно использовать только (:) и []. Проверьте, что ваша
-- функция на самом деле имеет более общий тип Monad m => [m a] -> m [a].
-- В Prelude такая функция называется sequence.

-- 5. Как известно, функция filter :: (a -> Bool) -> [a] -> [a]
-- принимает предикат и список и возвращает список тех элементов,
-- которые удовлетворяют предикату. Предположим теперь, что предикат
-- имеет тип a -> Maybe Bool. Таким образом, он может возвращать три
-- значения: Nothing, Just False и Just True. Напишите функцию
-- filterMaybe :: (a -> Maybe Bool) -> [a] -> Maybe [a]. Если хотя бы
-- на одном элементе списка предикат возвращает Nothing, то
-- filterMaybe также возвращает Nothing. Иначе filterMaybe возвращает
-- Just [x1, ..., xk], где x1, ..., xk — элементы исходного списка, на
-- которых предикат возвращает Just True. Проверьте работу filterMaybe
-- на предикате

p :: Int -> Maybe Bool
p n
  | n == 0 = Nothing
  | even n = Just True
  | otherwise = Just False

-- Также проверьте, что filterMaybe на самом деле имеет более общий тип:
-- Monad m => (a -> m Bool) -> [a] -> m [a]. В Control.Monad такая функция
-- называется filterM.

-- 6. Как работает функция filterM, если вместо монады Maybe ее
-- применить к списочной монаде?  Например, определим монадный
-- предикат следующим образом.

pM :: Int -> [Bool]
pM n = [n `mod` 3 == 0, n `mod` 5 == 0]

-- Что возвращает filterM pM [3,4,5]? Можете ли вы придумать, как с
-- помощью filterM в одну строчку написать функцию powerset,
-- возвращающую булеан списка (домашнее задание 3)?
