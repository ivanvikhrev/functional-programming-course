module BooleanSyntax where

-- Задача проекта: написать программу, которая манипулирует булевыми формулами.
-- В частности программа должна проверять членство функции, реализуемой формулой,
-- в пяти предполных классах Поста:
-- (1) функции, сохраняющие 0
-- (2) функции, сохраняющие 1
-- (3) самодвойственные функции
-- (4) монотонные функции
-- (5) линейные функции

-- Программа также должна генерировать случайные формулы для составления задач
-- по дисциплине "Теория дискретных функций". Это не так просто в Haskell,
-- потому что функция, генерирующая случайные числа, обычно реализуется
-- как функция с побочными эффектами (изменение состояния генератора), ведь
-- последовательные вызовы возвращают разные значения. Несмотря на то, что
-- в Haskell нет побочных эффектов, такое поведение можно реализовать с помощью
-- конструкции, которая называется монада, и которая широко используется
-- в Haskell несмотря на свою неочевидность.

-- В данном модуле находятся заготовки для реализации булевых функций.

-- Нульместные, одноместные и двуместные операции.

data Op = T | F | Neg | And | Or | If | Iff | Xor | Nand | Nor
  deriving (Eq, Enum, Bounded, Show)

-- If: импликация
-- Iff: эквиваленция
-- Xor: исключающее ИЛИ
-- Nand: отрицание конъюнкции (штрих Шеффера)
-- Nor: отрицание дизъюнкции (стрелка Пирса)

-- Таблицы истинности всех функций выше см. на с. 11 в книге:
-- Гаврилов Г.П., Сапоженко А.А. Задачи и упражнения по дискретной математике.
-- М.: Физматлит, 2005.
-- Там же есть и другие сведения, необходимые для этого проекта.

-- Каждой связке соответствует арность (количество принимаемых аргументов)

arity :: Op -> Int
arity T = 0
arity F = 0
arity Neg = 1
arity And = 2
arity Or = 2
arity If = 2
arity Iff = 2
arity Xor = 2
arity Nand = 2
arity Nor = 2

-- Также каждой связке соответствует приоритет. Чем больше приоритет, тем сильнее
-- связывает оператор. Приоритеты могут разными в разных учебниках; это только пример.

prec :: Op -> Int
prec T = 0
prec F = 0
prec Neg = 8
prec And = 7
prec Or = 6
prec If = 4
prec Iff = 5
prec Xor = 6
prec Nand = 6
prec Nor = 6

-- Любая операция с приоритетом 0. Нужна по техническим соображениям при
-- переводе формулы в строку.

noOp :: Op
noOp = T

-- Возвращает текстовое представление связок.
-- Тип ShowS и функция showString описаны в лекции 6.

opText :: Op -> ShowS
opText T = showString "1"
opText F = showString "0"
opText Neg = showString "~"
opText And = showString " "
opText Or = showString " v "
opText If = showString " -> "
opText Iff = showString " <-> "
opText Xor = showString " + "
opText Nand = showString " | "
opText Nor = showString " ↓ "

-- В дальнейшем
-- Возвращает представление связок в LaTeX
-- opLaTeX :: Op -> ShowS

-- В отличие от Haskell, где операторы могут быть не иметь
-- ассоциативности или быть лево- или правоассоциативными, будем
-- различать следующие случаи.

-- 1) Ассоциативная операция (And, Or, Xor, Iff): в последовательности
-- одинаковых операций скобки не пишутся, поскольку могут
-- расставляться любым способом.

-- Операции ниже не являются ассоциативными.

-- 2) Правоассоциативная операция. Если в последовательности
-- одинаковых операций скобки остутствуют, подразумевается, что они
-- группируются вправо (пример: If).

-- 3) Левоассоциативная операция. То же, что 2), только скобки
-- группируются влево (в данном наборе таких операций нет).

-- 4) Неассоциативная операция не имеют соглашения о группировки скобок
-- (примеры: Nand, Nor).  Скобки должны указываться явно, и отсутствие скобок в
-- последовательности одинаковых операций не допускается.

data AssocType = FA | LA | RA | NA deriving Eq

-- FA (full associativity): случай 1)
-- LA (left associativity): случай 3)
-- RA (right associativity): случай 2)
-- NA (no associativity): случай 4)

-- Возвращает ассоциативность связки

assoc :: Op -> AssocType
-- T, F, Neg не являются бинарными операторами, поэтому их
-- ассоциативность не определена
assoc T = NA
assoc F = NA
assoc Neg = NA
assoc And = FA
assoc Or = FA
assoc If = RA
assoc Iff = FA
assoc Xor = FA
assoc Nand = NA
assoc Nor = NA

-- Область определения и значения операций.
-- Должен быть членом классов Enum и Bounded

type Domain = Bool

-- Семантика связки, то есть булева функция, которая обозначается связкой

evalOp :: Op -> [Domain] -> Domain
evalOp T [] = True
evalOp F [] = False
evalOp Neg [x] = not x
evalOp And [x, y] = x && y
evalOp Or [x, y] = x || y
evalOp If [x, y] = not x || y
evalOp Iff [x, y] = x == y
evalOp Xor [x, y] = x /= y
evalOp Nand [x, y] = not (x && y)
evalOp Nor [x, y] = not (x || y)
